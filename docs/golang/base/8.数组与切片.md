# 数组与切片

### 1. 语法讲解

**数组**是固定长度的、具有相同数据类型元素的有序集合。数组在Go语言中是**值类型**，这意味着当数组被赋值给一个新变量或传递给函数时，会创建整个数组的副本。

```go
// 数组声明方式
var arr1 [3]int                    // 声明但不初始化
arr2 := [3]int{1, 2, 3}           // 声明并初始化
arr3 := [...]int{1, 2, 3, 4, 5}   // 编译器计算长度
```

**切片**是对数组的抽象，提供**动态大小**的灵活视图。切片是**引用类型**，包含三个组件：指向底层数组的指针、长度和容量。

```go
// 切片创建方式
var slice1 []int                    // 声明切片
slice2 := make([]int, 3, 5)        // 使用make，长度3，容量5
slice3 := []int{1, 2, 3}           // 字面量声明
slice4 := arr2[1:3]                // 从数组创建
```

切片的**扩容机制**：当切片容量不足时，Go会自动扩容。容量小于1024时通常翻倍，超过1024时增加25%左右。

### 2. 应用场景

**数组适用场景**：
- 存储固定大小的数据集合（如一周温度数据）
- 内存敏感场景，数组在栈上分配
- 加密/编码等需要精确控制内存布局的操作

**切片适用场景**：
- 动态数据集合（如读取未知长度的文件内容）
- 复用内存，避免复制（如截取日志子集）
- 实现栈/队列数据结构
- 高性能批量处理

### 3. 编程实例

**电商购物车实现**：

```go
package main

import "fmt"

type CartItem struct {
    Name     string
    Price    float64
    Quantity int
}

func main() {
    // 使用切片管理购物车商品（动态增减）
    var cart []CartItem
    
    // 添加商品
    cart = append(cart, CartItem{"笔记本电脑", 5999.99, 1})
    cart = append(cart, CartItem{"无线鼠标", 89.90, 2})
    cart = append(cart, CartItem{"电脑包", 120.50, 1})
    
    // 计算总价
    total := 0.0
    for _, item := range cart {
        total += item.Price * float64(item.Quantity)
    }
    
    fmt.Printf("购物车总价: ¥%.2f\n", total)
    fmt.Printf("商品数量: %d\n", len(cart))
    
    // 模拟商品下架（移除第一个商品）
    if len(cart) > 0 {
        cart = cart[1:]
    }
    
    fmt.Printf("移除后商品数量: %d\n", len(cart))
}
```

### 4. 其他用法

**切片高级操作**：

```go
package main

import "fmt"

func main() {
    // 1. 预分配容量优化性能
    ids := make([]int, 0, 100) // 长度0，容量100
    for i := 0; i < 100; i++ {
        ids = append(ids, i)
    }
    
    // 2. 切片复制避免内存泄漏
    importantData := make([]byte, 0, 10*1024*1024) // 10MB
    // ...填充数据...
    returnData := make([]byte, len(importantData))
    copy(returnData, importantData) // 复制需要的数据
    
    // 3. 批量处理
    data := make([]int, 1000)
    batchSize := 100
    for i := 0; i < len(data); i += batchSize {
        end := i + batchSize
        if end > len(data) {
            end = len(data)
        }
        batch := data[i:end]
        processBatch(batch)
    }
    
    // 4. 多维切片
    matrix := make([][]int, 3)
    for i := range matrix {
        matrix[i] = make([]int, 3)
    }
}

func processBatch(batch []int) {
    fmt.Printf("处理批次，大小: %d\n", len(batch))
}
```

### 5. 课时总结

- **数组**：固定长度、值类型、内存连续、适合小规模固定数据
- **切片**：动态长度、引用类型、包含指针/长度/容量、适合大多数集合操作
- **切片扩容**：容量不足时自动扩容，有一套特定的扩容策略
- **使用建议**：95%场景优先使用切片，已知最大规模时预分配容量