# Go语言常用标准库详解

## 1. 语法讲解

Go语言标准库提供了丰富的基础功能包，以下是最核心和常用的库：

- **fmt包**：格式化I/O操作，类似C语言的printf和scanf
- **os包**：操作系统功能接口，文件操作、环境变量、进程管理
- **io包**：基础I/O接口抽象，Reader/Writer接口
- **strings包**：字符串操作函数
- **strconv包**：字符串与基本类型转换
- **time包**：时间日期处理
- **encoding/json包**：JSON编码解码
- **net/http包**：HTTP客户端和服务器
- **sync包**：并发同步原语
- **flag包**：命令行参数解析

## 2. 应用场景

- **fmt/os/io**：系统工具开发、配置文件管理、日志处理
- **strings/strconv**：用户输入验证、数据清洗、格式转换
- **time**：定时任务、缓存过期、时间戳管理
- **encoding/json**：API开发、配置文件解析、数据序列化
- **net/http**：Web服务、微服务、API网关
- **sync**：并发编程、资源共享、性能优化

## 3. 编程实例

**场景：完整的Web API服务开发**

```go
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"
)

// 用户数据结构
type User struct {
	ID        int       `json:"id"`
	Name      string    `json:"name"`
	Email     string    `json:"email"`
	CreatedAt time.Time `json:"created_at"`
	Active    bool      `json:"active"`
}

// 内存存储
type UserStore struct {
	users map[int]User
	mu    sync.RWMutex
	nextID int
}

func NewUserStore() *UserStore {
	return &UserStore{
		users:  make(map[int]User),
		nextID: 1,
	}
}

// 添加用户
func (s *UserStore) AddUser(name, email string) User {
	s.mu.Lock()
	defer s.mu.Unlock()

	user := User{
		ID:        s.nextID,
		Name:      name,
		Email:     email,
		CreatedAt: time.Now(),
		Active:    true,
	}

	s.users[s.nextID] = user
	s.nextID++

	return user
}

// 获取用户
func (s *UserStore) GetUser(id int) (User, bool) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	user, exists := s.users[id]
	return user, exists
}

// 获取所有用户
func (s *UserStore) GetAllUsers() []User {
	s.mu.RLock()
	defer s.mu.RUnlock()

	users := make([]User, 0, len(s.users))
	for _, user := range s.users {
		users = append(users, user)
	}
	return users
}

// HTTP处理器
type UserHandler struct {
	store *UserStore
}

func NewUserHandler() *UserHandler {
	return &UserHandler{
		store: NewUserStore(),
	}
}

// 创建用户
func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// 读取请求体
	body, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "Error reading request body", http.StatusBadRequest)
		return
	}
	defer r.Body.Close()

	// 解析JSON
	var request struct {
		Name  string `json:"name"`
		Email string `json:"email"`
	}

	if err := json.Unmarshal(body, &request); err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	// 验证输入
	request.Name = strings.TrimSpace(request.Name)
	request.Email = strings.TrimSpace(request.Email)

	if request.Name == "" || request.Email == "" {
		http.Error(w, "Name and email are required", http.StatusBadRequest)
		return
	}

	// 创建用户
	user := h.store.AddUser(request.Name, request.Email)

	// 返回响应
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(user)
}

// 获取用户列表
func (h *UserHandler) GetUsers(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	users := h.store.GetAllUsers()

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(users)
}

// 获取单个用户
func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// 从URL路径提取ID
	path := strings.TrimPrefix(r.URL.Path, "/users/")
	id, err := strconv.Atoi(path)
	if err != nil {
		http.Error(w, "Invalid user ID", http.StatusBadRequest)
		return
	}

	user, exists := h.store.GetUser(id)
	if !exists {
		http.Error(w, "User not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(user)
}

// 配置文件管理
type Config struct {
	Port        int    `json:"port"`
	DatabaseURL string `json:"database_url"`
	LogLevel    string `json:"log_level"`
}

func LoadConfig(filename string) (*Config, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to open config file: %v", err)
	}
	defer file.Close()

	content, err := io.ReadAll(file)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %v", err)
	}

	var config Config
	if err := json.Unmarshal(content, &config); err != nil {
		return nil, fmt.Errorf("failed to parse config: %v", err)
	}

	return &config, nil
}

func SaveConfig(filename string, config *Config) error {
	file, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("failed to create config file: %v", err)
	}
	defer file.Close()

	data, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal config: %v", err)
	}

	_, err = file.Write(data)
	if err != nil {
		return fmt.Errorf("failed to write config: %v", err)
	}

	return nil
}

func main() {
	// 命令行参数解析
	var configFile string
	var port int
	flag.StringVar(&configFile, "config", "config.json", "Configuration file")
	flag.IntVar(&port, "port", 8080, "Server port")
	flag.Parse()

	// 加载配置
	config := &Config{
		Port:     port,
		LogLevel: "info",
	}

	if _, err := os.Stat(configFile); err == nil {
		loadedConfig, err := LoadConfig(configFile)
		if err != nil {
			log.Printf("Warning: Failed to load config: %v", err)
		} else {
			config = loadedConfig
		}
	}

	// 保存默认配置（如果文件不存在）
	if _, err := os.Stat(configFile); os.IsNotExist(err) {
		if err := SaveConfig(configFile, config); err != nil {
			log.Printf("Warning: Failed to save default config: %v", err)
		}
	}

	// 设置日志
	log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)
	log.Printf("Starting server on port %d", config.Port)

	// 初始化处理器
	userHandler := NewUserHandler()

	// 设置路由
	http.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodPost:
			userHandler.CreateUser(w, r)
		case http.MethodGet:
			userHandler.GetUsers(w, r)
		default:
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		}
	})

	http.HandleFunc("/users/", userHandler.GetUser)

	// 健康检查端点
	http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"status":    "healthy",
			"timestamp": time.Now().Format(time.RFC3339),
		})
	})

	// 启动服务器
	addr := fmt.Sprintf(":%d", config.Port)
	log.Printf("Server started at http://localhost%s", addr)
	log.Fatal(http.ListenAndServe(addr, nil))
}
```

## 4. 其他重要标准库用法

```go
package main

import (
	"bufio"
	"compress/gzip"
	"crypto/md5"
	"encoding/csv"
	"encoding/xml"
	"fmt"
	"hash/fnv"
	"io"
	"math/rand"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"text/template"
)

// 1. text/template - 模板引擎
func demonstrateTemplates() {
	fmt.Println("\n=== text/template演示 ===")
	
	const templateText = `
用户信息:
=========
姓名: {{.Name}}
年龄: {{.Age}}
邮箱: {{.Email}}
{{if .Active}}状态: 活跃{{else}}状态: 非活跃{{end}}
注册时间: {{.RegisteredAt.Format "2006-01-02"}}
{{range .Hobbies}}爱好: {{.}}
{{end}}
`
	
	type User struct {
		Name         string
		Age          int
		Email        string
		Active       bool
		RegisteredAt time.Time
		Hobbies      []string
	}
	
	user := User{
		Name:         "李四",
		Age:          28,
		Email:        "lisi@example.com",
		Active:       true,
		RegisteredAt: time.Now(),
		Hobbies:      []string{"阅读", "游泳", "编程"},
	}
	
	tmpl, err := template.New("user").Parse(templateText)
	if err != nil {
		fmt.Printf("模板解析错误: %v\n", err)
		return
	}
	
	fmt.Println("模板渲染结果:")
	err = tmpl.Execute(os.Stdout, user)
	if err != nil {
		fmt.Printf("模板执行错误: %v\n", err)
	}
}

// 2. compress/gzip - 压缩解压
func demonstrateCompression() {
	fmt.Println("\n\n=== 压缩解压演示 ===")
	
	originalData := "这是一段需要压缩的文本数据，" +
		"重复内容" + strings.Repeat("重复", 10) +
		"结束。"
	
	// 压缩
	var compressed bytes.Buffer
	gzWriter := gzip.NewWriter(&compressed)
	gzWriter.Write([]byte(originalData))
	gzWriter.Close()
	
	fmt.Printf("原始大小: %d bytes\n", len(originalData))
	fmt.Printf("压缩后大小: %d bytes\n", compressed.Len())
	fmt.Printf("压缩率: %.1f%%\n", 
		float64(compressed.Len())/float64(len(originalData))*100)
	
	// 解压
	gzReader, err := gzip.NewReader(&compressed)
	if err != nil {
		fmt.Printf("创建解压读取器错误: %v\n", err)
		return
	}
	defer gzReader.Close()
	
	decompressedData, err := io.ReadAll(gzReader)
	if err != nil {
		fmt.Printf("解压错误: %v\n", err)
		return
	}
	
	fmt.Printf("解压后数据: %s\n", string(decompressedData))
}

// 3. bufio - 缓冲I/O
func demonstrateBufferedIO() {
	fmt.Println("\n=== 缓冲I/O演示 ===")
	
	// 创建测试文件
	file, err := os.Create("test_buffered.txt")
	if err != nil {
		fmt.Printf("创建文件错误: %v\n", err)
		return
	}
	defer file.Close()
	
	// 使用bufio写入
	writer := bufio.NewWriter(file)
	for i := 1; i <= 5; i++ {
		writer.WriteString(fmt.Sprintf("这是第 %d 行数据\n", i))
	}
	writer.Flush() // 确保数据写入磁盘
	
	fmt.Println("缓冲写入完成")
	
	// 使用bufio读取
	file, err = os.Open("test_buffered.txt")
	if err != nil {
		fmt.Printf("打开文件错误: %v\n", err)
		return
	}
	defer file.Close()
	
	reader := bufio.NewReader(file)
	fmt.Println("文件内容:")
	for {
		line, err := reader.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			fmt.Printf("读取错误: %v\n", err)
			return
		}
		fmt.Print("> " + line)
	}
}

func main() {
	demonstrateTemplates()
	demonstrateCompression()
	demonstrateBufferedIO()
	
	// 清理测试文件
	os.Remove("test_buffered.txt")
}
```

## 5. 课时总结

**核心标准库分类：**

1. **I/O操作类**
   - `fmt`：格式化输入输出
   - `os`：操作系统接口
   - `io`：基础I/O抽象
   - `bufio`：缓冲I/O

2. **数据处理类**
   - `strings`：字符串操作
   - `strconv`：类型转换
   - `encoding/json`：JSON处理
   - `encoding/xml`：XML处理
   - `encoding/csv`：CSV处理

3. **网络与并发类**
   - `net/http`：HTTP服务
   - `sync`：并发同步
   - `context`：上下文管理

4. **工具类**
   - `time`：时间日期
   - `flag`：命令行参数
   - `path/filepath`：路径操作
   - `compress/*`：压缩解压
